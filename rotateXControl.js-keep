// rotateXControl.js
import { Quaternion, Euler } from './node_modules/three/build/three.module.js';

export function applyRotateXControl(renderer, rolodex) {
    var isDragging = false;
    var previousMousePosition = { x: 0, y: 0 };
    var rolodexRotation = 0; // Default angle

    renderer.domElement.addEventListener('mousedown', function(e) {
        isDragging = true;
    });

    renderer.domElement.addEventListener('mousemove', function(e) {
        var deltaMove = {
            x: e.offsetX - previousMousePosition.x,
            y: e.offsetY - previousMousePosition.y
        };

        if (isDragging) {
            var deltaRotationQuaternion = new Quaternion().setFromEuler(
                new Euler(toRadians(deltaMove.y * 0.1), 0, 0, 'YXZ')
            );

            rolodexRotation += toRadians(deltaMove.y * 0.1);
            rolodexRotation = Math.max(Math.min(rolodexRotation, Math.PI / 2), -Math.PI / 2); // Restrict rotation to Â±90 degrees

            rolodex.quaternion.multiplyQuaternions(deltaRotationQuaternion, rolodex.quaternion);
            rolodex.updateMatrixWorld(true); // Update the world matrix
        }

        previousMousePosition = {
            x: e.offsetX,
            y: e.offsetY
        };
    });

    renderer.domElement.addEventListener('mouseup', function(e) {
        isDragging = false;
    });

    function toRadians(angle) {
        return angle * (Math.PI / 180);
    }
}
